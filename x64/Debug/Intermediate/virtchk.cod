; Listing generated by Microsoft (R) Optimizing Compiler Version 15.00.30729.207 

include listing.inc

INCLUDELIB LIBCMT
INCLUDELIB OLDNAMES

_DATA	SEGMENT
$SG4669	DB	'GenuineIntel', 00H
	ORG $+3
$SG4672	DB	'AuthenticAMD', 00H
	ORG $+3
$SG4682	DB	'GenuineIntel', 00H
	ORG $+3
$SG4684	DB	'This processor is manufactured by Intel Corporation!', 0aH
	DB	00H
	ORG $+10
$SG4689	DB	'To detect Intel VT-x capability, virtchk needs to load d'
	DB	'river!', 0aH, 00H
$SG4690	DB	'You have to make sure virtchk is started with administra'
	DB	'tor privilege!', 0aH, 00H
$SG4691	DB	'pause', 00H
	ORG $+2
$SG4699	DB	'This processor supports Intel VT-x!', 0aH, 00H
	ORG $+3
$SG4700	DB	'VMCS Revision ID of This Processor: %d', 0aH, 00H
$SG4702	DB	'This processor recommends Write-Back Memory for VMCS!', 0aH
	DB	00H
	ORG $+1
$SG4704	DB	'This processor recommends Non-Cached Memory for VMCS!', 0aH
	DB	00H
	ORG $+1
$SG4711	DB	'Intel EPT is supported!', 0aH, 00H
	ORG $+7
$SG4713	DB	'Intel EPT 2MB-Paging is supported!', 0aH, 00H
	ORG $+4
$SG4715	DB	'Intel EPT 1GB-Paging is supported!', 0aH, 00H
	ORG $+4
$SG4717	DB	'Non-Cached EPT Paging Structure is supported!', 0aH, 00H
	ORG $+1
$SG4719	DB	'Write-Back EPT Paging Structure is supported!', 0aH, 00H
	ORG $+1
$SG4721	DB	'Execute-Only Translation is supported!', 0aH, 00H
$SG4723	DB	'Hardware-Accelerated Nesting Virtualization is supported'
	DB	'!', 0aH, 00H
	ORG $+5
$SG4725	DB	'Intel SGX Virtualization is supported!', 0aH, 00H
$SG4727	DB	'MSR-Bitmap is supported!', 0aH, 00H
	ORG $+6
$SG4729	DB	'External-Interrupt Interception is supported!', 0aH, 00H
	ORG $+1
$SG4730	DB	'Maximum supported Auto-Load MSR Count: %d', 0aH, 00H
	ORG $+5
$SG4739	DB	'AuthenticAMD', 00H
	ORG $+3
$SG4741	DB	'This processor is manufactured by AMD Incorporated!', 0aH
	DB	00H
	ORG $+3
$SG4749	DB	'This processor supports AMD-V!', 0aH, 00H
$SG4752	DB	'SVM Revision Id: %d', 0aH, 00H
	ORG $+3
$SG4753	DB	'Number of available ASID: %d', 0aH, 00H
	ORG $+2
$SG4755	DB	'Nested Paging (NPT/RVI) is supported!', 0aH, 00H
	ORG $+1
$SG4757	DB	'LBR Virtualization is supported!', 0aH, 00H
	ORG $+6
$SG4759	DB	'SVM Lock is supported!', 0aH, 00H
$SG4761	DB	'Next-RIP Saving is supported!', 0aH, 00H
	ORG $+1
$SG4763	DB	'TSC Ratio Control is supported!', 0aH, 00H
	ORG $+7
$SG4765	DB	'VMCB Clean-Bit is supported!', 0aH, 00H
	ORG $+2
$SG4767	DB	'Flush-By-ASID is supported!', 0aH, 00H
	ORG $+3
$SG4769	DB	'Decode Assist is supported!', 0aH, 00H
	ORG $+3
$SG4771	DB	'Pause Filter is supported!', 0aH, 00H
	ORG $+4
$SG4773	DB	'Pause Filter Threshold is supported!', 0aH, 00H
	ORG $+2
$SG4775	DB	'Advanced Virtual Interrupt Controller is supported!', 0aH
	DB	00H
	ORG $+3
$SG4777	DB	'Hardware-Accelerated SVM Instruction Virtualization is s'
	DB	'upported!', 0aH, 00H
	ORG $+13
$SG4779	DB	'Hardware-Accelerated SVM Global Interrupt Flag Virtualiz'
	DB	'ation is supported!', 0aH, 00H
	ORG $+3
$SG4790	DB	'Your processor is unknown!', 0aH, 00H
$SG4791	DB	'pause', 00H
_DATA	ENDS
PUBLIC	vtc_confirm_cpu
;	COMDAT pdata
; File d:\projects\virtchk\virtchk\virtchk.h
pdata	SEGMENT
$pdata$vtc_confirm_cpu DD imagerel $LN19
	DD	imagerel $LN19+251
	DD	imagerel $unwind$vtc_confirm_cpu
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$vtc_confirm_cpu DD 020601H
	DD	030027206H
; Function compile flags: /Odtp
; File d:\projects\virtchk\virtchk\virtchk.c
xdata	ENDS
;	COMDAT vtc_confirm_cpu
_TEXT	SEGMENT
vs_str$ = 0
id$4813 = 16
$T4819 = 32
$T4820 = 40
$T4821 = 48
vtc_confirm_cpu PROC					; COMDAT

; 7    : {

$LN19:
  00000	40 53		 push	 rbx
  00002	48 83 ec 40	 sub	 rsp, 64			; 00000040H

; 8    : 	char vs_str[13];
; 9    : 	vtc_cpuid(0,0,null,(u32*)&vs_str[0],(u32*)&vs_str[8],(u32*)&vs_str[4]);

  00006	48 8d 44 24 04	 lea	 rax, QWORD PTR vs_str$[rsp+4]
  0000b	48 89 44 24 30	 mov	 QWORD PTR $T4821[rsp], rax
  00010	48 8d 44 24 08	 lea	 rax, QWORD PTR vs_str$[rsp+8]
  00015	48 89 44 24 28	 mov	 QWORD PTR $T4820[rsp], rax
  0001a	48 8d 04 24	 lea	 rax, QWORD PTR vs_str$[rsp]
  0001e	48 89 44 24 20	 mov	 QWORD PTR $T4819[rsp], rax
  00023	33 c0		 xor	 eax, eax
  00025	33 c9		 xor	 ecx, ecx
  00027	0f a2		 cpuid
  00029	44 8b c2	 mov	 r8d, edx
  0002c	8b d1		 mov	 edx, ecx
  0002e	8b c8		 mov	 ecx, eax
  00030	48 8d 44 24 10	 lea	 rax, QWORD PTR id$4813[rsp]
  00035	89 08		 mov	 DWORD PTR [rax], ecx
  00037	89 58 04	 mov	 DWORD PTR [rax+4], ebx
  0003a	89 50 08	 mov	 DWORD PTR [rax+8], edx
  0003d	44 89 40 0c	 mov	 DWORD PTR [rax+12], r8d
  00041	33 c0		 xor	 eax, eax
  00043	48 85 c0	 test	 rax, rax
  00046	74 0b		 je	 SHORT $LN10@vtc_confir
  00048	8b 44 24 10	 mov	 eax, DWORD PTR id$4813[rsp]
  0004c	89 04 25 00 00
	00 00		 mov	 DWORD PTR ds:0, eax
$LN10@vtc_confir:
  00053	48 83 7c 24 20
	00		 cmp	 QWORD PTR $T4819[rsp], 0
  00059	74 0b		 je	 SHORT $LN9@vtc_confir
  0005b	48 8b 4c 24 20	 mov	 rcx, QWORD PTR $T4819[rsp]
  00060	8b 44 24 14	 mov	 eax, DWORD PTR id$4813[rsp+4]
  00064	89 01		 mov	 DWORD PTR [rcx], eax
$LN9@vtc_confir:
  00066	48 83 7c 24 28
	00		 cmp	 QWORD PTR $T4820[rsp], 0
  0006c	74 0b		 je	 SHORT $LN8@vtc_confir
  0006e	48 8b 4c 24 28	 mov	 rcx, QWORD PTR $T4820[rsp]
  00073	8b 44 24 18	 mov	 eax, DWORD PTR id$4813[rsp+8]
  00077	89 01		 mov	 DWORD PTR [rcx], eax
$LN8@vtc_confir:
  00079	48 83 7c 24 30
	00		 cmp	 QWORD PTR $T4821[rsp], 0
  0007f	74 0b		 je	 SHORT $LN7@vtc_confir
  00081	48 8b 4c 24 30	 mov	 rcx, QWORD PTR $T4821[rsp]
  00086	8b 44 24 1c	 mov	 eax, DWORD PTR id$4813[rsp+12]
  0008a	89 01		 mov	 DWORD PTR [rcx], eax
$LN7@vtc_confir:

; 10   : 	vs_str[12]=0;

  0008c	c6 44 24 0c 00	 mov	 BYTE PTR vs_str$[rsp+12], 0

; 11   : 	if(strcmp(vs_str,"GenuineIntel")==0)

  00091	48 8d 14 24	 lea	 rdx, QWORD PTR vs_str$[rsp]
  00095	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG4669
  0009c	48 2b ca	 sub	 rcx, rdx
$LL16@vtc_confir:
  0009f	0f b6 02	 movzx	 eax, BYTE PTR [rdx]
  000a2	3a 04 0a	 cmp	 al, BYTE PTR [rdx+rcx]
  000a5	75 0c		 jne	 SHORT $LN18@vtc_confir
  000a7	48 83 c2 01	 add	 rdx, 1
  000ab	84 c0		 test	 al, al
  000ad	75 f0		 jne	 SHORT $LL16@vtc_confir
  000af	33 c0		 xor	 eax, eax
  000b1	eb 05		 jmp	 SHORT $LN17@vtc_confir
$LN18@vtc_confir:
  000b3	1b c0		 sbb	 eax, eax
  000b5	83 d8 ff	 sbb	 eax, -1
$LN17@vtc_confir:
  000b8	85 c0		 test	 eax, eax
  000ba	75 06		 jne	 SHORT $LN4@vtc_confir

; 12   : 		return intel_processor;

  000bc	32 c0		 xor	 al, al
  000be	eb 35		 jmp	 SHORT $LN5@vtc_confir
  000c0	eb 33		 jmp	 SHORT $LN3@vtc_confir
$LN4@vtc_confir:

; 13   : 	else if(strcmp(vs_str,"AuthenticAMD")==0)

  000c2	48 8d 14 24	 lea	 rdx, QWORD PTR vs_str$[rsp]
  000c6	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG4672
  000cd	48 2b ca	 sub	 rcx, rdx
$LL13@vtc_confir:
  000d0	0f b6 02	 movzx	 eax, BYTE PTR [rdx]
  000d3	3a 04 0a	 cmp	 al, BYTE PTR [rdx+rcx]
  000d6	75 0c		 jne	 SHORT $LN15@vtc_confir
  000d8	48 83 c2 01	 add	 rdx, 1
  000dc	84 c0		 test	 al, al
  000de	75 f0		 jne	 SHORT $LL13@vtc_confir
  000e0	33 c0		 xor	 eax, eax
  000e2	eb 05		 jmp	 SHORT $LN14@vtc_confir
$LN15@vtc_confir:
  000e4	1b c0		 sbb	 eax, eax
  000e6	83 d8 ff	 sbb	 eax, -1
$LN14@vtc_confir:
  000e9	85 c0		 test	 eax, eax
  000eb	75 06		 jne	 SHORT $LN2@vtc_confir

; 14   : 		return amd_processor;

  000ed	b0 01		 mov	 al, 1
  000ef	eb 04		 jmp	 SHORT $LN5@vtc_confir

; 15   : 	else

  000f1	eb 02		 jmp	 SHORT $LN1@vtc_confir
$LN2@vtc_confir:

; 16   : 		return unknown_processor;

  000f3	b0 ff		 mov	 al, 255			; 000000ffH
$LN1@vtc_confir:
$LN3@vtc_confir:
$LN5@vtc_confir:

; 17   : }

  000f5	48 83 c4 40	 add	 rsp, 64			; 00000040H
  000f9	5b		 pop	 rbx
  000fa	c3		 ret	 0
vtc_confirm_cpu ENDP
_TEXT	ENDS
PUBLIC	vtc_print_vmx_info
EXTRN	unload_driver:PROC
EXTRN	vtc_rdmsr:PROC
EXTRN	load_driver:PROC
EXTRN	system:PROC
EXTRN	printf:PROC
;	COMDAT pdata
; File d:\projects\virtchk\virtchk\virtchk.h
pdata	SEGMENT
$pdata$vtc_print_vmx_info DD imagerel $LN36
	DD	imagerel $LN36+1118
	DD	imagerel $unwind$vtc_print_vmx_info
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$vtc_print_vmx_info DD 030901H
	DD	01a0109H
	DD	03002H
; Function compile flags: /Odtp
; File d:\projects\virtchk\virtchk\virtchk.c
xdata	ENDS
;	COMDAT vtc_print_vmx_info
_TEXT	SEGMENT
vs_str$ = 32
max$ = 48
feat_info$4683 = 52
pin_ctrl$4694 = 56
vtbas$4693 = 64
exit_ctrl$4696 = 72
vtmisc$4698 = 80
entry_ctrl$4697 = 88
proc_ctrl$4695 = 96
proc2_ctrl$4708 = 104
ept_cap$4710 = 112
id$4837 = 120
$T4843 = 136
$T4844 = 144
$T4845 = 152
$T4846 = 160
id$4849 = 168
$T4855 = 184
tv266 = 192
vtc_print_vmx_info PROC					; COMDAT

; 20   : {

$LN36:
  00000	40 53		 push	 rbx
  00002	48 81 ec d0 00
	00 00		 sub	 rsp, 208		; 000000d0H

; 21   : 	char vs_str[13];
; 22   : 	u32 max;
; 23   : 	vtc_cpuid(0,0,&max,(u32*)&vs_str[0],(u32*)&vs_str[8],(u32*)&vs_str[4]);

  00009	48 8d 44 24 24	 lea	 rax, QWORD PTR vs_str$[rsp+4]
  0000e	48 89 84 24 a0
	00 00 00	 mov	 QWORD PTR $T4846[rsp], rax
  00016	48 8d 44 24 28	 lea	 rax, QWORD PTR vs_str$[rsp+8]
  0001b	48 89 84 24 98
	00 00 00	 mov	 QWORD PTR $T4845[rsp], rax
  00023	48 8d 44 24 20	 lea	 rax, QWORD PTR vs_str$[rsp]
  00028	48 89 84 24 90
	00 00 00	 mov	 QWORD PTR $T4844[rsp], rax
  00030	48 8d 44 24 30	 lea	 rax, QWORD PTR max$[rsp]
  00035	48 89 84 24 88
	00 00 00	 mov	 QWORD PTR $T4843[rsp], rax
  0003d	33 c0		 xor	 eax, eax
  0003f	33 c9		 xor	 ecx, ecx
  00041	0f a2		 cpuid
  00043	44 8b c2	 mov	 r8d, edx
  00046	8b d1		 mov	 edx, ecx
  00048	8b c8		 mov	 ecx, eax
  0004a	48 8d 44 24 78	 lea	 rax, QWORD PTR id$4837[rsp]
  0004f	89 08		 mov	 DWORD PTR [rax], ecx
  00051	89 58 04	 mov	 DWORD PTR [rax+4], ebx
  00054	89 50 08	 mov	 DWORD PTR [rax+8], edx
  00057	44 89 40 0c	 mov	 DWORD PTR [rax+12], r8d
  0005b	48 83 bc 24 88
	00 00 00 00	 cmp	 QWORD PTR $T4843[rsp], 0
  00064	74 0e		 je	 SHORT $LN24@vtc_print_
  00066	48 8b 8c 24 88
	00 00 00	 mov	 rcx, QWORD PTR $T4843[rsp]
  0006e	8b 44 24 78	 mov	 eax, DWORD PTR id$4837[rsp]
  00072	89 01		 mov	 DWORD PTR [rcx], eax
$LN24@vtc_print_:
  00074	48 83 bc 24 90
	00 00 00 00	 cmp	 QWORD PTR $T4844[rsp], 0
  0007d	74 0e		 je	 SHORT $LN23@vtc_print_
  0007f	48 8b 8c 24 90
	00 00 00	 mov	 rcx, QWORD PTR $T4844[rsp]
  00087	8b 44 24 7c	 mov	 eax, DWORD PTR id$4837[rsp+4]
  0008b	89 01		 mov	 DWORD PTR [rcx], eax
$LN23@vtc_print_:
  0008d	48 83 bc 24 98
	00 00 00 00	 cmp	 QWORD PTR $T4845[rsp], 0
  00096	74 11		 je	 SHORT $LN22@vtc_print_
  00098	48 8b 8c 24 98
	00 00 00	 mov	 rcx, QWORD PTR $T4845[rsp]
  000a0	8b 84 24 80 00
	00 00		 mov	 eax, DWORD PTR id$4837[rsp+8]
  000a7	89 01		 mov	 DWORD PTR [rcx], eax
$LN22@vtc_print_:
  000a9	48 83 bc 24 a0
	00 00 00 00	 cmp	 QWORD PTR $T4846[rsp], 0
  000b2	74 11		 je	 SHORT $LN21@vtc_print_
  000b4	48 8b 8c 24 a0
	00 00 00	 mov	 rcx, QWORD PTR $T4846[rsp]
  000bc	8b 84 24 84 00
	00 00		 mov	 eax, DWORD PTR id$4837[rsp+12]
  000c3	89 01		 mov	 DWORD PTR [rcx], eax
$LN21@vtc_print_:

; 24   : 	if(strcmp(vs_str,"GenuineIntel")==0 && max>=1)

  000c5	48 8d 54 24 20	 lea	 rdx, QWORD PTR vs_str$[rsp]
  000ca	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG4682
  000d1	48 2b ca	 sub	 rcx, rdx
$LL33@vtc_print_:
  000d4	0f b6 02	 movzx	 eax, BYTE PTR [rdx]
  000d7	3a 04 0a	 cmp	 al, BYTE PTR [rdx+rcx]
  000da	75 0c		 jne	 SHORT $LN35@vtc_print_
  000dc	48 83 c2 01	 add	 rdx, 1
  000e0	84 c0		 test	 al, al
  000e2	75 f0		 jne	 SHORT $LL33@vtc_print_
  000e4	33 c0		 xor	 eax, eax
  000e6	eb 05		 jmp	 SHORT $LN34@vtc_print_
$LN35@vtc_print_:
  000e8	1b c0		 sbb	 eax, eax
  000ea	83 d8 ff	 sbb	 eax, -1
$LN34@vtc_print_:
  000ed	85 c0		 test	 eax, eax
  000ef	0f 85 60 03 00
	00		 jne	 $LN18@vtc_print_
  000f5	83 7c 24 30 01	 cmp	 DWORD PTR max$[rsp], 1
  000fa	0f 82 55 03 00
	00		 jb	 $LN18@vtc_print_

; 25   : 	{
; 26   : 		u32 feat_info;
; 27   : 		printf("This processor is manufactured by Intel Corporation!\n");

  00100	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG4684
  00107	e8 00 00 00 00	 call	 printf

; 28   : 		vtc_cpuid(1,0,null,null,&feat_info,null);

  0010c	48 8d 54 24 34	 lea	 rdx, QWORD PTR feat_info$4683[rsp]
  00111	48 89 94 24 b8
	00 00 00	 mov	 QWORD PTR $T4855[rsp], rdx
  00119	b8 01 00 00 00	 mov	 eax, 1
  0011e	33 c9		 xor	 ecx, ecx
  00120	0f a2		 cpuid
  00122	44 8b c2	 mov	 r8d, edx
  00125	8b d1		 mov	 edx, ecx
  00127	8b c8		 mov	 ecx, eax
  00129	48 8d 84 24 a8
	00 00 00	 lea	 rax, QWORD PTR id$4849[rsp]
  00131	89 08		 mov	 DWORD PTR [rax], ecx
  00133	89 58 04	 mov	 DWORD PTR [rax+4], ebx
  00136	89 50 08	 mov	 DWORD PTR [rax+8], edx
  00139	44 89 40 0c	 mov	 DWORD PTR [rax+12], r8d
  0013d	33 c0		 xor	 eax, eax
  0013f	48 85 c0	 test	 rax, rax
  00142	74 0e		 je	 SHORT $LN30@vtc_print_
  00144	8b 84 24 a8 00
	00 00		 mov	 eax, DWORD PTR id$4849[rsp]
  0014b	89 04 25 00 00
	00 00		 mov	 DWORD PTR ds:0, eax
$LN30@vtc_print_:
  00152	33 c0		 xor	 eax, eax
  00154	48 85 c0	 test	 rax, rax
  00157	74 0e		 je	 SHORT $LN29@vtc_print_
  00159	8b 84 24 ac 00
	00 00		 mov	 eax, DWORD PTR id$4849[rsp+4]
  00160	89 04 25 00 00
	00 00		 mov	 DWORD PTR ds:0, eax
$LN29@vtc_print_:
  00167	48 83 bc 24 b8
	00 00 00 00	 cmp	 QWORD PTR $T4855[rsp], 0
  00170	74 11		 je	 SHORT $LN28@vtc_print_
  00172	48 8b 8c 24 b8
	00 00 00	 mov	 rcx, QWORD PTR $T4855[rsp]
  0017a	8b 84 24 b0 00
	00 00		 mov	 eax, DWORD PTR id$4849[rsp+8]
  00181	89 01		 mov	 DWORD PTR [rcx], eax
$LN28@vtc_print_:
  00183	33 c0		 xor	 eax, eax
  00185	48 85 c0	 test	 rax, rax
  00188	74 0e		 je	 SHORT $LN27@vtc_print_
  0018a	8b 84 24 b4 00
	00 00		 mov	 eax, DWORD PTR id$4849[rsp+12]
  00191	89 04 25 00 00
	00 00		 mov	 DWORD PTR ds:0, eax
$LN27@vtc_print_:

; 29   : 		if(vtc_bt(&feat_info,5))

  00198	48 8d 44 24 34	 lea	 rax, QWORD PTR feat_info$4683[rsp]
  0019d	48 89 84 24 c0
	00 00 00	 mov	 QWORD PTR tv266[rsp], rax
  001a5	48 8b 84 24 c0
	00 00 00	 mov	 rax, QWORD PTR tv266[rsp]
  001ad	0f ba 20 05	 bt	 DWORD PTR [rax], 5
  001b1	0f 92 c0	 setb	 al
  001b4	0f b6 c0	 movzx	 eax, al
  001b7	85 c0		 test	 eax, eax
  001b9	0f 84 96 02 00
	00		 je	 $LN17@vtc_print_

; 30   : 		{
; 31   : 			printf("To detect Intel VT-x capability, virtchk needs to load driver!\n");

  001bf	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG4689
  001c6	e8 00 00 00 00	 call	 printf

; 32   : 			printf("You have to make sure virtchk is started with administrator privilege!\n");

  001cb	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG4690
  001d2	e8 00 00 00 00	 call	 printf

; 33   : 			system("pause");

  001d7	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG4691
  001de	e8 00 00 00 00	 call	 system

; 34   : 			if(load_driver())

  001e3	e8 00 00 00 00	 call	 load_driver
  001e8	85 c0		 test	 eax, eax
  001ea	0f 84 65 02 00
	00		 je	 $LN16@vtc_print_

; 35   : 			{
; 36   : 				vmx_basic_msr vtbas;
; 37   : 				vmx_pinbased_ctrl_msr pin_ctrl;
; 38   : 				vmx_procbased_ctrl_msr proc_ctrl;
; 39   : 				vmx_exit_ctrl_msr exit_ctrl;
; 40   : 				vmx_entry_ctrl_msr entry_ctrl;
; 41   : 				vmx_misc_msr vtmisc;
; 42   : 				printf("This processor supports Intel VT-x!\n");

  001f0	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG4699
  001f7	e8 00 00 00 00	 call	 printf

; 43   : 				vtbas.value=vtc_rdmsr(ia32_vmx_basic);

  001fc	b9 80 04 00 00	 mov	 ecx, 1152		; 00000480H
  00201	e8 00 00 00 00	 call	 vtc_rdmsr
  00206	48 89 44 24 40	 mov	 QWORD PTR vtbas$4693[rsp], rax

; 44   : 				printf("VMCS Revision ID of This Processor: %d\n",vtbas.revision_id);

  0020b	48 8b 54 24 40	 mov	 rdx, QWORD PTR vtbas$4693[rsp]
  00210	48 81 e2 ff ff
	ff 7f		 and	 rdx, 2147483647		; 7fffffffH
  00217	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG4700
  0021e	e8 00 00 00 00	 call	 printf

; 45   : 				if(vtbas.memory_type==6)

  00223	48 8b 44 24 40	 mov	 rax, QWORD PTR vtbas$4693[rsp]
  00228	48 c1 e8 32	 shr	 rax, 50			; 00000032H
  0022c	48 83 e0 0f	 and	 rax, 15
  00230	48 83 f8 06	 cmp	 rax, 6
  00234	75 0e		 jne	 SHORT $LN15@vtc_print_

; 46   : 					printf("This processor recommends Write-Back Memory for VMCS!\n");

  00236	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG4702
  0023d	e8 00 00 00 00	 call	 printf

; 47   : 				else

  00242	eb 0c		 jmp	 SHORT $LN14@vtc_print_
$LN15@vtc_print_:

; 48   : 					printf("This processor recommends Non-Cached Memory for VMCS!\n");

  00244	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG4704
  0024b	e8 00 00 00 00	 call	 printf
$LN14@vtc_print_:

; 49   : 				if(vtbas.use_true_msr)

  00250	48 8b 44 24 40	 mov	 rax, QWORD PTR vtbas$4693[rsp]
  00255	48 c1 e8 37	 shr	 rax, 55			; 00000037H
  00259	48 83 e0 01	 and	 rax, 1
  0025d	48 85 c0	 test	 rax, rax
  00260	74 3e		 je	 SHORT $LN13@vtc_print_

; 50   : 				{
; 51   : 					pin_ctrl.value=vtc_rdmsr(ia32_vmx_true_pinbased_ctrl);

  00262	b9 8d 04 00 00	 mov	 ecx, 1165		; 0000048dH
  00267	e8 00 00 00 00	 call	 vtc_rdmsr
  0026c	48 89 44 24 38	 mov	 QWORD PTR pin_ctrl$4694[rsp], rax

; 52   : 					proc_ctrl.value=vtc_rdmsr(ia32_vmx_true_procbased_ctrl);

  00271	b9 8e 04 00 00	 mov	 ecx, 1166		; 0000048eH
  00276	e8 00 00 00 00	 call	 vtc_rdmsr
  0027b	48 89 44 24 60	 mov	 QWORD PTR proc_ctrl$4695[rsp], rax

; 53   : 					exit_ctrl.value=vtc_rdmsr(ia32_vmx_true_exit_ctrl);

  00280	b9 8f 04 00 00	 mov	 ecx, 1167		; 0000048fH
  00285	e8 00 00 00 00	 call	 vtc_rdmsr
  0028a	48 89 44 24 48	 mov	 QWORD PTR exit_ctrl$4696[rsp], rax

; 54   : 					entry_ctrl.value=vtc_rdmsr(ia32_vmx_true_entry_ctrl);

  0028f	b9 90 04 00 00	 mov	 ecx, 1168		; 00000490H
  00294	e8 00 00 00 00	 call	 vtc_rdmsr
  00299	48 89 44 24 58	 mov	 QWORD PTR entry_ctrl$4697[rsp], rax

; 55   : 				}
; 56   : 				else

  0029e	eb 3c		 jmp	 SHORT $LN12@vtc_print_
$LN13@vtc_print_:

; 57   : 				{
; 58   : 					pin_ctrl.value=vtc_rdmsr(ia32_vmx_pinbased_ctrl);

  002a0	b9 81 04 00 00	 mov	 ecx, 1153		; 00000481H
  002a5	e8 00 00 00 00	 call	 vtc_rdmsr
  002aa	48 89 44 24 38	 mov	 QWORD PTR pin_ctrl$4694[rsp], rax

; 59   : 					proc_ctrl.value=vtc_rdmsr(ia32_vmx_procbased_ctrl);

  002af	b9 82 04 00 00	 mov	 ecx, 1154		; 00000482H
  002b4	e8 00 00 00 00	 call	 vtc_rdmsr
  002b9	48 89 44 24 60	 mov	 QWORD PTR proc_ctrl$4695[rsp], rax

; 60   : 					exit_ctrl.value=vtc_rdmsr(ia32_vmx_exit_ctrl);

  002be	b9 83 04 00 00	 mov	 ecx, 1155		; 00000483H
  002c3	e8 00 00 00 00	 call	 vtc_rdmsr
  002c8	48 89 44 24 48	 mov	 QWORD PTR exit_ctrl$4696[rsp], rax

; 61   : 					entry_ctrl.value=vtc_rdmsr(ia32_vmx_entry_ctrl);

  002cd	b9 84 04 00 00	 mov	 ecx, 1156		; 00000484H
  002d2	e8 00 00 00 00	 call	 vtc_rdmsr
  002d7	48 89 44 24 58	 mov	 QWORD PTR entry_ctrl$4697[rsp], rax
$LN12@vtc_print_:

; 62   : 				}
; 63   : 				if(proc_ctrl.allowed1_settings.activate_secondary_control)

  002dc	8b 44 24 64	 mov	 eax, DWORD PTR proc_ctrl$4695[rsp+4]
  002e0	c1 e8 1f	 shr	 eax, 31
  002e3	83 e0 01	 and	 eax, 1
  002e6	85 c0		 test	 eax, eax
  002e8	0f 84 01 01 00
	00		 je	 $LN11@vtc_print_

; 64   : 				{
; 65   : 					vmx_procbased2_ctrl_msr proc2_ctrl;
; 66   : 					proc2_ctrl.value=vtc_rdmsr(ia32_vmx_procbased2_ctrl);

  002ee	b9 8b 04 00 00	 mov	 ecx, 1163		; 0000048bH
  002f3	e8 00 00 00 00	 call	 vtc_rdmsr
  002f8	48 89 44 24 68	 mov	 QWORD PTR proc2_ctrl$4708[rsp], rax

; 67   : 					if(proc2_ctrl.allowed1_settings.enable_ept)

  002fd	8b 44 24 6c	 mov	 eax, DWORD PTR proc2_ctrl$4708[rsp+4]
  00301	d1 e8		 shr	 eax, 1
  00303	83 e0 01	 and	 eax, 1
  00306	85 c0		 test	 eax, eax
  00308	0f 84 ad 00 00
	00		 je	 $LN10@vtc_print_

; 68   : 					{
; 69   : 						vmx_ept_vpid_cap_msr ept_cap;
; 70   : 						printf("Intel EPT is supported!\n");

  0030e	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG4711
  00315	e8 00 00 00 00	 call	 printf

; 71   : 						ept_cap.value=vtc_rdmsr(ia32_vmx_ept_vpid_cap);

  0031a	b9 8c 04 00 00	 mov	 ecx, 1164		; 0000048cH
  0031f	e8 00 00 00 00	 call	 vtc_rdmsr
  00324	48 89 44 24 70	 mov	 QWORD PTR ept_cap$4710[rsp], rax

; 72   : 						if(ept_cap.map_2mb_page)

  00329	48 8b 44 24 70	 mov	 rax, QWORD PTR ept_cap$4710[rsp]
  0032e	48 c1 e8 10	 shr	 rax, 16
  00332	48 83 e0 01	 and	 rax, 1
  00336	48 85 c0	 test	 rax, rax
  00339	74 0c		 je	 SHORT $LN9@vtc_print_

; 73   : 							printf("Intel EPT 2MB-Paging is supported!\n");

  0033b	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG4713
  00342	e8 00 00 00 00	 call	 printf
$LN9@vtc_print_:

; 74   : 						if(ept_cap.map_1gb_page)

  00347	48 8b 44 24 70	 mov	 rax, QWORD PTR ept_cap$4710[rsp]
  0034c	48 c1 e8 11	 shr	 rax, 17
  00350	48 83 e0 01	 and	 rax, 1
  00354	48 85 c0	 test	 rax, rax
  00357	74 0c		 je	 SHORT $LN8@vtc_print_

; 75   : 							printf("Intel EPT 1GB-Paging is supported!\n");

  00359	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG4715
  00360	e8 00 00 00 00	 call	 printf
$LN8@vtc_print_:

; 76   : 						if(ept_cap.uncacheable_ept)

  00365	48 8b 44 24 70	 mov	 rax, QWORD PTR ept_cap$4710[rsp]
  0036a	48 c1 e8 08	 shr	 rax, 8
  0036e	48 83 e0 01	 and	 rax, 1
  00372	48 85 c0	 test	 rax, rax
  00375	74 0c		 je	 SHORT $LN7@vtc_print_

; 77   : 							printf("Non-Cached EPT Paging Structure is supported!\n");

  00377	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG4717
  0037e	e8 00 00 00 00	 call	 printf
$LN7@vtc_print_:

; 78   : 						if(ept_cap.writeback_ept)

  00383	48 8b 44 24 70	 mov	 rax, QWORD PTR ept_cap$4710[rsp]
  00388	48 c1 e8 0e	 shr	 rax, 14
  0038c	48 83 e0 01	 and	 rax, 1
  00390	48 85 c0	 test	 rax, rax
  00393	74 0c		 je	 SHORT $LN6@vtc_print_

; 79   : 							printf("Write-Back EPT Paging Structure is supported!\n");

  00395	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG4719
  0039c	e8 00 00 00 00	 call	 printf
$LN6@vtc_print_:

; 80   : 						if(ept_cap.exec_only_trans)

  003a1	48 8b 44 24 70	 mov	 rax, QWORD PTR ept_cap$4710[rsp]
  003a6	48 83 e0 01	 and	 rax, 1
  003aa	48 85 c0	 test	 rax, rax
  003ad	74 0c		 je	 SHORT $LN5@vtc_print_

; 81   : 							printf("Execute-Only Translation is supported!\n");

  003af	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG4721
  003b6	e8 00 00 00 00	 call	 printf
$LN5@vtc_print_:
$LN10@vtc_print_:

; 82   : 					}
; 83   : 					if(proc2_ctrl.allowed1_settings.vmcs_shadowing)

  003bb	8b 44 24 6c	 mov	 eax, DWORD PTR proc2_ctrl$4708[rsp+4]
  003bf	c1 e8 0e	 shr	 eax, 14
  003c2	83 e0 01	 and	 eax, 1
  003c5	85 c0		 test	 eax, eax
  003c7	74 0c		 je	 SHORT $LN4@vtc_print_

; 84   : 						printf("Hardware-Accelerated Nesting Virtualization is supported!\n");

  003c9	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG4723
  003d0	e8 00 00 00 00	 call	 printf
$LN4@vtc_print_:

; 85   : 					if(proc2_ctrl.allowed1_settings.enable_encls_exiting)

  003d5	8b 44 24 6c	 mov	 eax, DWORD PTR proc2_ctrl$4708[rsp+4]
  003d9	c1 e8 0f	 shr	 eax, 15
  003dc	83 e0 01	 and	 eax, 1
  003df	85 c0		 test	 eax, eax
  003e1	74 0c		 je	 SHORT $LN3@vtc_print_

; 86   : 						printf("Intel SGX Virtualization is supported!\n");

  003e3	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG4725
  003ea	e8 00 00 00 00	 call	 printf
$LN3@vtc_print_:
$LN11@vtc_print_:

; 87   : 				}
; 88   : 				if(proc_ctrl.allowed1_settings.use_msr_bitmap)

  003ef	8b 44 24 64	 mov	 eax, DWORD PTR proc_ctrl$4695[rsp+4]
  003f3	c1 e8 1c	 shr	 eax, 28
  003f6	83 e0 01	 and	 eax, 1
  003f9	85 c0		 test	 eax, eax
  003fb	74 0c		 je	 SHORT $LN2@vtc_print_

; 89   : 					printf("MSR-Bitmap is supported!\n");

  003fd	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG4727
  00404	e8 00 00 00 00	 call	 printf
$LN2@vtc_print_:

; 90   : 				if(pin_ctrl.allowed1_settings.external_interrupt)

  00409	8b 44 24 3c	 mov	 eax, DWORD PTR pin_ctrl$4694[rsp+4]
  0040d	83 e0 01	 and	 eax, 1
  00410	85 c0		 test	 eax, eax
  00412	74 0c		 je	 SHORT $LN1@vtc_print_

; 91   : 					printf("External-Interrupt Interception is supported!\n");

  00414	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG4729
  0041b	e8 00 00 00 00	 call	 printf
$LN1@vtc_print_:

; 92   : 				vtmisc.value=vtc_rdmsr(ia32_vmx_misc);

  00420	b9 85 04 00 00	 mov	 ecx, 1157		; 00000485H
  00425	e8 00 00 00 00	 call	 vtc_rdmsr
  0042a	48 89 44 24 50	 mov	 QWORD PTR vtmisc$4698[rsp], rax

; 93   : 				printf("Maximum supported Auto-Load MSR Count: %d\n",(vtmisc.max_auto_load_msr+1)<<9);

  0042f	48 8b 54 24 50	 mov	 rdx, QWORD PTR vtmisc$4698[rsp]
  00434	48 c1 ea 19	 shr	 rdx, 25
  00438	48 83 e2 07	 and	 rdx, 7
  0043c	48 83 c2 01	 add	 rdx, 1
  00440	48 c1 e2 09	 shl	 rdx, 9
  00444	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG4730
  0044b	e8 00 00 00 00	 call	 printf

; 94   : 				unload_driver();

  00450	e8 00 00 00 00	 call	 unload_driver
$LN16@vtc_print_:
$LN17@vtc_print_:
$LN18@vtc_print_:

; 95   : 			}
; 96   : 		}
; 97   : 	}
; 98   : }

  00455	48 81 c4 d0 00
	00 00		 add	 rsp, 208		; 000000d0H
  0045c	5b		 pop	 rbx
  0045d	c3		 ret	 0
vtc_print_vmx_info ENDP
_TEXT	ENDS
PUBLIC	vtc_print_svm_info
;	COMDAT pdata
; File d:\projects\virtchk\virtchk\virtchk.h
pdata	SEGMENT
$pdata$vtc_print_svm_info DD imagerel $LN39
	DD	imagerel $LN39+969
	DD	imagerel $unwind$vtc_print_svm_info
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$vtc_print_svm_info DD 030901H
	DD	0180109H
	DD	03002H
; Function compile flags: /Odtp
; File d:\projects\virtchk\virtchk\virtchk.c
xdata	ENDS
;	COMDAT vtc_print_svm_info
_TEXT	SEGMENT
vs_str$ = 32
max$ = 48
feat_info$4740 = 52
nasid$4746 = 56
rev$4747 = 60
svi$4748 = 64
id$4868 = 72
$T4874 = 88
$T4875 = 96
$T4876 = 104
$T4877 = 112
id$4880 = 120
$T4886 = 136
id$4889 = 144
$T4895 = 160
$T4896 = 168
$T4897 = 176
tv206 = 184
vtc_print_svm_info PROC					; COMDAT

; 101  : {

$LN39:
  00000	40 53		 push	 rbx
  00002	48 81 ec c0 00
	00 00		 sub	 rsp, 192		; 000000c0H

; 102  : 	char vs_str[13];
; 103  : 	u32 max;
; 104  : 	vtc_cpuid(0x80000000,0,&max,(u32*)&vs_str[0],(u32*)&vs_str[8],(u32*)&vs_str[4]);

  00009	48 8d 44 24 24	 lea	 rax, QWORD PTR vs_str$[rsp+4]
  0000e	48 89 44 24 70	 mov	 QWORD PTR $T4877[rsp], rax
  00013	48 8d 44 24 28	 lea	 rax, QWORD PTR vs_str$[rsp+8]
  00018	48 89 44 24 68	 mov	 QWORD PTR $T4876[rsp], rax
  0001d	48 8d 44 24 20	 lea	 rax, QWORD PTR vs_str$[rsp]
  00022	48 89 44 24 60	 mov	 QWORD PTR $T4875[rsp], rax
  00027	48 8d 44 24 30	 lea	 rax, QWORD PTR max$[rsp]
  0002c	48 89 44 24 58	 mov	 QWORD PTR $T4874[rsp], rax
  00031	b8 00 00 00 80	 mov	 eax, -2147483648	; ffffffff80000000H
  00036	33 c9		 xor	 ecx, ecx
  00038	0f a2		 cpuid
  0003a	44 8b c2	 mov	 r8d, edx
  0003d	8b d1		 mov	 edx, ecx
  0003f	8b c8		 mov	 ecx, eax
  00041	48 8d 44 24 48	 lea	 rax, QWORD PTR id$4868[rsp]
  00046	89 08		 mov	 DWORD PTR [rax], ecx
  00048	89 58 04	 mov	 DWORD PTR [rax+4], ebx
  0004b	89 50 08	 mov	 DWORD PTR [rax+8], edx
  0004e	44 89 40 0c	 mov	 DWORD PTR [rax+12], r8d
  00052	48 83 7c 24 58
	00		 cmp	 QWORD PTR $T4874[rsp], 0
  00058	74 0b		 je	 SHORT $LN21@vtc_print_@2
  0005a	48 8b 4c 24 58	 mov	 rcx, QWORD PTR $T4874[rsp]
  0005f	8b 44 24 48	 mov	 eax, DWORD PTR id$4868[rsp]
  00063	89 01		 mov	 DWORD PTR [rcx], eax
$LN21@vtc_print_@2:
  00065	48 83 7c 24 60
	00		 cmp	 QWORD PTR $T4875[rsp], 0
  0006b	74 0b		 je	 SHORT $LN20@vtc_print_@2
  0006d	48 8b 4c 24 60	 mov	 rcx, QWORD PTR $T4875[rsp]
  00072	8b 44 24 4c	 mov	 eax, DWORD PTR id$4868[rsp+4]
  00076	89 01		 mov	 DWORD PTR [rcx], eax
$LN20@vtc_print_@2:
  00078	48 83 7c 24 68
	00		 cmp	 QWORD PTR $T4876[rsp], 0
  0007e	74 0b		 je	 SHORT $LN19@vtc_print_@2
  00080	48 8b 4c 24 68	 mov	 rcx, QWORD PTR $T4876[rsp]
  00085	8b 44 24 50	 mov	 eax, DWORD PTR id$4868[rsp+8]
  00089	89 01		 mov	 DWORD PTR [rcx], eax
$LN19@vtc_print_@2:
  0008b	48 83 7c 24 70
	00		 cmp	 QWORD PTR $T4877[rsp], 0
  00091	74 0b		 je	 SHORT $LN18@vtc_print_@2
  00093	48 8b 4c 24 70	 mov	 rcx, QWORD PTR $T4877[rsp]
  00098	8b 44 24 54	 mov	 eax, DWORD PTR id$4868[rsp+12]
  0009c	89 01		 mov	 DWORD PTR [rcx], eax
$LN18@vtc_print_@2:

; 105  : 	if(strcmp(vs_str,"AuthenticAMD")==0 && max>=0x8000000A)

  0009e	48 8d 54 24 20	 lea	 rdx, QWORD PTR vs_str$[rsp]
  000a3	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG4739
  000aa	48 2b ca	 sub	 rcx, rdx
$LL36@vtc_print_@2:
  000ad	0f b6 02	 movzx	 eax, BYTE PTR [rdx]
  000b0	3a 04 0a	 cmp	 al, BYTE PTR [rdx+rcx]
  000b3	75 0c		 jne	 SHORT $LN38@vtc_print_@2
  000b5	48 83 c2 01	 add	 rdx, 1
  000b9	84 c0		 test	 al, al
  000bb	75 f0		 jne	 SHORT $LL36@vtc_print_@2
  000bd	33 c0		 xor	 eax, eax
  000bf	eb 05		 jmp	 SHORT $LN37@vtc_print_@2
$LN38@vtc_print_@2:
  000c1	1b c0		 sbb	 eax, eax
  000c3	83 d8 ff	 sbb	 eax, -1
$LN37@vtc_print_@2:
  000c6	85 c0		 test	 eax, eax
  000c8	0f 85 f2 02 00
	00		 jne	 $LN15@vtc_print_@2
  000ce	81 7c 24 30 0a
	00 00 80	 cmp	 DWORD PTR max$[rsp], -2147483638 ; 8000000aH
  000d6	0f 82 e4 02 00
	00		 jb	 $LN15@vtc_print_@2

; 106  : 	{
; 107  : 		u32 feat_info;
; 108  : 		printf("This processor is manufactured by AMD Incorporated!\n");

  000dc	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG4741
  000e3	e8 00 00 00 00	 call	 printf

; 109  : 		vtc_cpuid(0x80000001,0,null,&feat_info,null,null);

  000e8	48 8d 54 24 34	 lea	 rdx, QWORD PTR feat_info$4740[rsp]
  000ed	48 89 94 24 88
	00 00 00	 mov	 QWORD PTR $T4886[rsp], rdx
  000f5	b8 01 00 00 80	 mov	 eax, -2147483647	; ffffffff80000001H
  000fa	33 c9		 xor	 ecx, ecx
  000fc	0f a2		 cpuid
  000fe	44 8b c2	 mov	 r8d, edx
  00101	8b d1		 mov	 edx, ecx
  00103	8b c8		 mov	 ecx, eax
  00105	48 8d 44 24 78	 lea	 rax, QWORD PTR id$4880[rsp]
  0010a	89 08		 mov	 DWORD PTR [rax], ecx
  0010c	89 58 04	 mov	 DWORD PTR [rax+4], ebx
  0010f	89 50 08	 mov	 DWORD PTR [rax+8], edx
  00112	44 89 40 0c	 mov	 DWORD PTR [rax+12], r8d
  00116	33 c0		 xor	 eax, eax
  00118	48 85 c0	 test	 rax, rax
  0011b	74 0b		 je	 SHORT $LN27@vtc_print_@2
  0011d	8b 44 24 78	 mov	 eax, DWORD PTR id$4880[rsp]
  00121	89 04 25 00 00
	00 00		 mov	 DWORD PTR ds:0, eax
$LN27@vtc_print_@2:
  00128	48 83 bc 24 88
	00 00 00 00	 cmp	 QWORD PTR $T4886[rsp], 0
  00131	74 0e		 je	 SHORT $LN26@vtc_print_@2
  00133	48 8b 8c 24 88
	00 00 00	 mov	 rcx, QWORD PTR $T4886[rsp]
  0013b	8b 44 24 7c	 mov	 eax, DWORD PTR id$4880[rsp+4]
  0013f	89 01		 mov	 DWORD PTR [rcx], eax
$LN26@vtc_print_@2:
  00141	33 c0		 xor	 eax, eax
  00143	48 85 c0	 test	 rax, rax
  00146	74 0e		 je	 SHORT $LN25@vtc_print_@2
  00148	8b 84 24 80 00
	00 00		 mov	 eax, DWORD PTR id$4880[rsp+8]
  0014f	89 04 25 00 00
	00 00		 mov	 DWORD PTR ds:0, eax
$LN25@vtc_print_@2:
  00156	33 c0		 xor	 eax, eax
  00158	48 85 c0	 test	 rax, rax
  0015b	74 0e		 je	 SHORT $LN24@vtc_print_@2
  0015d	8b 84 24 84 00
	00 00		 mov	 eax, DWORD PTR id$4880[rsp+12]
  00164	89 04 25 00 00
	00 00		 mov	 DWORD PTR ds:0, eax
$LN24@vtc_print_@2:

; 110  : 		if(vtc_bt(&feat_info,2))

  0016b	48 8d 44 24 34	 lea	 rax, QWORD PTR feat_info$4740[rsp]
  00170	48 89 84 24 b8
	00 00 00	 mov	 QWORD PTR tv206[rsp], rax
  00178	48 8b 84 24 b8
	00 00 00	 mov	 rax, QWORD PTR tv206[rsp]
  00180	0f ba 20 02	 bt	 DWORD PTR [rax], 2
  00184	0f 92 c0	 setb	 al
  00187	0f b6 c0	 movzx	 eax, al
  0018a	85 c0		 test	 eax, eax
  0018c	0f 84 2e 02 00
	00		 je	 $LN14@vtc_print_@2

; 111  : 		{
; 112  : 			u32 nasid,rev;
; 113  : 			svm_feat_info svi;
; 114  : 			printf("This processor supports AMD-V!\n");

  00192	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG4749
  00199	e8 00 00 00 00	 call	 printf

; 115  : 			vtc_cpuid(0x8000000A,0,&rev,&nasid,null,(u32*)&svi);

  0019e	48 8d 54 24 40	 lea	 rdx, QWORD PTR svi$4748[rsp]
  001a3	48 89 94 24 b0
	00 00 00	 mov	 QWORD PTR $T4897[rsp], rdx
  001ab	48 8d 44 24 38	 lea	 rax, QWORD PTR nasid$4746[rsp]
  001b0	48 89 84 24 a8
	00 00 00	 mov	 QWORD PTR $T4896[rsp], rax
  001b8	48 8d 44 24 3c	 lea	 rax, QWORD PTR rev$4747[rsp]
  001bd	48 89 84 24 a0
	00 00 00	 mov	 QWORD PTR $T4895[rsp], rax
  001c5	b8 0a 00 00 80	 mov	 eax, -2147483638	; ffffffff8000000aH
  001ca	33 c9		 xor	 ecx, ecx
  001cc	0f a2		 cpuid
  001ce	44 8b c2	 mov	 r8d, edx
  001d1	8b d1		 mov	 edx, ecx
  001d3	8b c8		 mov	 ecx, eax
  001d5	48 8d 84 24 90
	00 00 00	 lea	 rax, QWORD PTR id$4889[rsp]
  001dd	89 08		 mov	 DWORD PTR [rax], ecx
  001df	89 58 04	 mov	 DWORD PTR [rax+4], ebx
  001e2	89 50 08	 mov	 DWORD PTR [rax+8], edx
  001e5	44 89 40 0c	 mov	 DWORD PTR [rax+12], r8d
  001e9	48 83 bc 24 a0
	00 00 00 00	 cmp	 QWORD PTR $T4895[rsp], 0
  001f2	74 11		 je	 SHORT $LN33@vtc_print_@2
  001f4	48 8b 8c 24 a0
	00 00 00	 mov	 rcx, QWORD PTR $T4895[rsp]
  001fc	8b 84 24 90 00
	00 00		 mov	 eax, DWORD PTR id$4889[rsp]
  00203	89 01		 mov	 DWORD PTR [rcx], eax
$LN33@vtc_print_@2:
  00205	48 83 bc 24 a8
	00 00 00 00	 cmp	 QWORD PTR $T4896[rsp], 0
  0020e	74 11		 je	 SHORT $LN32@vtc_print_@2
  00210	48 8b 8c 24 a8
	00 00 00	 mov	 rcx, QWORD PTR $T4896[rsp]
  00218	8b 84 24 94 00
	00 00		 mov	 eax, DWORD PTR id$4889[rsp+4]
  0021f	89 01		 mov	 DWORD PTR [rcx], eax
$LN32@vtc_print_@2:
  00221	33 c0		 xor	 eax, eax
  00223	48 85 c0	 test	 rax, rax
  00226	74 0e		 je	 SHORT $LN31@vtc_print_@2
  00228	8b 84 24 98 00
	00 00		 mov	 eax, DWORD PTR id$4889[rsp+8]
  0022f	89 04 25 00 00
	00 00		 mov	 DWORD PTR ds:0, eax
$LN31@vtc_print_@2:
  00236	48 83 bc 24 b0
	00 00 00 00	 cmp	 QWORD PTR $T4897[rsp], 0
  0023f	74 11		 je	 SHORT $LN30@vtc_print_@2
  00241	48 8b 8c 24 b0
	00 00 00	 mov	 rcx, QWORD PTR $T4897[rsp]
  00249	8b 84 24 9c 00
	00 00		 mov	 eax, DWORD PTR id$4889[rsp+12]
  00250	89 01		 mov	 DWORD PTR [rcx], eax
$LN30@vtc_print_@2:

; 116  : 			printf("SVM Revision Id: %d\n",rev);

  00252	8b 54 24 3c	 mov	 edx, DWORD PTR rev$4747[rsp]
  00256	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG4752
  0025d	e8 00 00 00 00	 call	 printf

; 117  : 			printf("Number of available ASID: %d\n",nasid);

  00262	8b 54 24 38	 mov	 edx, DWORD PTR nasid$4746[rsp]
  00266	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG4753
  0026d	e8 00 00 00 00	 call	 printf

; 118  : 			if(svi.npt)

  00272	8b 44 24 40	 mov	 eax, DWORD PTR svi$4748[rsp]
  00276	83 e0 01	 and	 eax, 1
  00279	85 c0		 test	 eax, eax
  0027b	74 0c		 je	 SHORT $LN13@vtc_print_@2

; 119  : 				printf("Nested Paging (NPT/RVI) is supported!\n");

  0027d	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG4755
  00284	e8 00 00 00 00	 call	 printf
$LN13@vtc_print_@2:

; 120  : 			if(svi.lbr_virt)

  00289	8b 44 24 40	 mov	 eax, DWORD PTR svi$4748[rsp]
  0028d	d1 e8		 shr	 eax, 1
  0028f	83 e0 01	 and	 eax, 1
  00292	85 c0		 test	 eax, eax
  00294	74 0c		 je	 SHORT $LN12@vtc_print_@2

; 121  : 				printf("LBR Virtualization is supported!\n");

  00296	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG4757
  0029d	e8 00 00 00 00	 call	 printf
$LN12@vtc_print_@2:

; 122  : 			if(svi.svm_lock)

  002a2	8b 44 24 40	 mov	 eax, DWORD PTR svi$4748[rsp]
  002a6	c1 e8 02	 shr	 eax, 2
  002a9	83 e0 01	 and	 eax, 1
  002ac	85 c0		 test	 eax, eax
  002ae	74 0c		 je	 SHORT $LN11@vtc_print_@2

; 123  : 				printf("SVM Lock is supported!\n");

  002b0	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG4759
  002b7	e8 00 00 00 00	 call	 printf
$LN11@vtc_print_@2:

; 124  : 			if(svi.next_rip)

  002bc	8b 44 24 40	 mov	 eax, DWORD PTR svi$4748[rsp]
  002c0	c1 e8 03	 shr	 eax, 3
  002c3	83 e0 01	 and	 eax, 1
  002c6	85 c0		 test	 eax, eax
  002c8	74 0c		 je	 SHORT $LN10@vtc_print_@2

; 125  : 				printf("Next-RIP Saving is supported!\n");

  002ca	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG4761
  002d1	e8 00 00 00 00	 call	 printf
$LN10@vtc_print_@2:

; 126  : 			if(svi.tsc_rate)

  002d6	8b 44 24 40	 mov	 eax, DWORD PTR svi$4748[rsp]
  002da	c1 e8 04	 shr	 eax, 4
  002dd	83 e0 01	 and	 eax, 1
  002e0	85 c0		 test	 eax, eax
  002e2	74 0c		 je	 SHORT $LN9@vtc_print_@2

; 127  : 				printf("TSC Ratio Control is supported!\n");

  002e4	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG4763
  002eb	e8 00 00 00 00	 call	 printf
$LN9@vtc_print_@2:

; 128  : 			if(svi.vmcb_clean)

  002f0	8b 44 24 40	 mov	 eax, DWORD PTR svi$4748[rsp]
  002f4	c1 e8 05	 shr	 eax, 5
  002f7	83 e0 01	 and	 eax, 1
  002fa	85 c0		 test	 eax, eax
  002fc	74 0c		 je	 SHORT $LN8@vtc_print_@2

; 129  : 				printf("VMCB Clean-Bit is supported!\n");

  002fe	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG4765
  00305	e8 00 00 00 00	 call	 printf
$LN8@vtc_print_@2:

; 130  : 			if(svi.flush_asid)

  0030a	8b 44 24 40	 mov	 eax, DWORD PTR svi$4748[rsp]
  0030e	c1 e8 06	 shr	 eax, 6
  00311	83 e0 01	 and	 eax, 1
  00314	85 c0		 test	 eax, eax
  00316	74 0c		 je	 SHORT $LN7@vtc_print_@2

; 131  : 				printf("Flush-By-ASID is supported!\n");

  00318	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG4767
  0031f	e8 00 00 00 00	 call	 printf
$LN7@vtc_print_@2:

; 132  : 			if(svi.decoder)

  00324	8b 44 24 40	 mov	 eax, DWORD PTR svi$4748[rsp]
  00328	c1 e8 07	 shr	 eax, 7
  0032b	83 e0 01	 and	 eax, 1
  0032e	85 c0		 test	 eax, eax
  00330	74 0c		 je	 SHORT $LN6@vtc_print_@2

; 133  : 				printf("Decode Assist is supported!\n");

  00332	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG4769
  00339	e8 00 00 00 00	 call	 printf
$LN6@vtc_print_@2:

; 134  : 			if(svi.pause_filter)

  0033e	8b 44 24 40	 mov	 eax, DWORD PTR svi$4748[rsp]
  00342	c1 e8 0a	 shr	 eax, 10
  00345	83 e0 01	 and	 eax, 1
  00348	85 c0		 test	 eax, eax
  0034a	74 0c		 je	 SHORT $LN5@vtc_print_@2

; 135  : 				printf("Pause Filter is supported!\n");

  0034c	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG4771
  00353	e8 00 00 00 00	 call	 printf
$LN5@vtc_print_@2:

; 136  : 			if(svi.pause_filter_threshold)

  00358	8b 44 24 40	 mov	 eax, DWORD PTR svi$4748[rsp]
  0035c	c1 e8 0c	 shr	 eax, 12
  0035f	83 e0 01	 and	 eax, 1
  00362	85 c0		 test	 eax, eax
  00364	74 0c		 je	 SHORT $LN4@vtc_print_@2

; 137  : 				printf("Pause Filter Threshold is supported!\n");

  00366	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG4773
  0036d	e8 00 00 00 00	 call	 printf
$LN4@vtc_print_@2:

; 138  : 			if(svi.avic)

  00372	8b 44 24 40	 mov	 eax, DWORD PTR svi$4748[rsp]
  00376	c1 e8 0d	 shr	 eax, 13
  00379	83 e0 01	 and	 eax, 1
  0037c	85 c0		 test	 eax, eax
  0037e	74 0c		 je	 SHORT $LN3@vtc_print_@2

; 139  : 				printf("Advanced Virtual Interrupt Controller is supported!\n");

  00380	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG4775
  00387	e8 00 00 00 00	 call	 printf
$LN3@vtc_print_@2:

; 140  : 			if(svi.svm_ins_virt)

  0038c	8b 44 24 40	 mov	 eax, DWORD PTR svi$4748[rsp]
  00390	c1 e8 0f	 shr	 eax, 15
  00393	83 e0 01	 and	 eax, 1
  00396	85 c0		 test	 eax, eax
  00398	74 0c		 je	 SHORT $LN2@vtc_print_@2

; 141  : 				printf("Hardware-Accelerated SVM Instruction Virtualization is supported!\n");

  0039a	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG4777
  003a1	e8 00 00 00 00	 call	 printf
$LN2@vtc_print_@2:

; 142  : 			if(svi.svm_gif_virt)

  003a6	8b 44 24 40	 mov	 eax, DWORD PTR svi$4748[rsp]
  003aa	c1 e8 10	 shr	 eax, 16
  003ad	83 e0 01	 and	 eax, 1
  003b0	85 c0		 test	 eax, eax
  003b2	74 0c		 je	 SHORT $LN1@vtc_print_@2

; 143  : 				printf("Hardware-Accelerated SVM Global Interrupt Flag Virtualization is supported!\n");

  003b4	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG4779
  003bb	e8 00 00 00 00	 call	 printf
$LN1@vtc_print_@2:
$LN14@vtc_print_@2:
$LN15@vtc_print_@2:

; 144  : 		}
; 145  : 	}
; 146  : }

  003c0	48 81 c4 c0 00
	00 00		 add	 rsp, 192		; 000000c0H
  003c7	5b		 pop	 rbx
  003c8	c3		 ret	 0
vtc_print_svm_info ENDP
_TEXT	ENDS
PUBLIC	vtc_main
;	COMDAT pdata
pdata	SEGMENT
$pdata$vtc_main DD imagerel $LN8
	DD	imagerel $LN8+80
	DD	imagerel $unwind$vtc_main
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$vtc_main DD 010401H
	DD	06204H
; Function compile flags: /Odtp
xdata	ENDS
;	COMDAT vtc_main
_TEXT	SEGMENT
cpu_manuf$ = 32
tv66 = 36
vtc_main PROC						; COMDAT

; 149  : {

$LN8:
  00000	48 83 ec 38	 sub	 rsp, 56			; 00000038H

; 150  : 	u8 cpu_manuf=vtc_confirm_cpu();

  00004	e8 00 00 00 00	 call	 vtc_confirm_cpu
  00009	88 44 24 20	 mov	 BYTE PTR cpu_manuf$[rsp], al

; 151  : 	switch(cpu_manuf)

  0000d	8a 44 24 20	 mov	 al, BYTE PTR cpu_manuf$[rsp]
  00011	88 44 24 24	 mov	 BYTE PTR tv66[rsp], al
  00015	80 7c 24 24 00	 cmp	 BYTE PTR tv66[rsp], 0
  0001a	74 09		 je	 SHORT $LN3@vtc_main
  0001c	80 7c 24 24 01	 cmp	 BYTE PTR tv66[rsp], 1
  00021	74 09		 je	 SHORT $LN2@vtc_main
  00023	eb 0e		 jmp	 SHORT $LN1@vtc_main
$LN3@vtc_main:

; 152  : 	{
; 153  : 		case intel_processor:
; 154  : 		{
; 155  : 			vtc_print_vmx_info();

  00025	e8 00 00 00 00	 call	 vtc_print_vmx_info

; 156  : 			break;

  0002a	eb 13		 jmp	 SHORT $LN4@vtc_main
$LN2@vtc_main:

; 157  : 		}
; 158  : 		case amd_processor:
; 159  : 		{
; 160  : 			vtc_print_svm_info();

  0002c	e8 00 00 00 00	 call	 vtc_print_svm_info

; 161  : 			break;

  00031	eb 0c		 jmp	 SHORT $LN4@vtc_main
$LN1@vtc_main:

; 162  : 		}
; 163  : 		default:
; 164  : 		{
; 165  : 			printf("Your processor is unknown!\n");

  00033	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG4790
  0003a	e8 00 00 00 00	 call	 printf
$LN4@vtc_main:

; 166  : 			break;
; 167  : 		}
; 168  : 	}
; 169  : 	system("pause");

  0003f	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG4791
  00046	e8 00 00 00 00	 call	 system

; 170  : }

  0004b	48 83 c4 38	 add	 rsp, 56			; 00000038H
  0004f	c3		 ret	 0
vtc_main ENDP
_TEXT	ENDS
END
